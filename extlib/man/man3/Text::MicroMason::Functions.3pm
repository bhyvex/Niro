.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "MicroMason::Functions 3"
.TH MicroMason::Functions 3 "2007-01-30" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Text::MicroMason::Functions \- Function Exporter for Simple Mason Templates
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Use the execute function to parse and evalute a template:
.PP
.Vb 2
\&    use Text::MicroMason::Functions qw( execute );
\&    print execute($template, \(aqname\(aq=>\(aqDave\(aq);
.Ve
.PP
Or compile it into a subroutine, and evaluate repeatedly:
.PP
.Vb 4
\&    use Text::MicroMason::Functions qw( compile );
\&    $coderef = compile($template);
\&    print $coderef\->(\(aqname\(aq=>\(aqDave\(aq);
\&    print $coderef\->(\(aqname\(aq=>\(aqBob\(aq);
.Ve
.PP
Templates stored in files can be run directly or included in others:
.PP
.Vb 2
\&    use Text::MicroMason::Functions qw( execute_file );
\&    print execute_file( "./greeting.msn", \(aqname\(aq=>\(aqCharles\(aq);
.Ve
.PP
Safe usage restricts templates from accessing your files or data:
.PP
.Vb 2
\&    use Text::MicroMason::Functions qw( safe_execute );
\&    print safe_execute( $template, \(aqname\(aq=>\(aqBob\(aq);
.Ve
.PP
All above functions are available in an error-catching \*(L"try_*\*(R" form:
.PP
.Vb 2
\&    use Text::MicroMason::Functions qw( try_execute );
\&    ($result, $error) = try_execute( $template, \(aqname\(aq=>\(aqAlice\(aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
As an alternative to the object-oriented interface, text containing MicroMason markup code can be compiled and executed by calling the following functions. 
.PP
Please note that this interface is maintained primarily for backward compatibility with version 1 of Text::MicroMason, and it does not provide access to some of the newer features.
.PP
Each function creates a new MicroMason object, including any necessary traits such as Safe compilation or CatchErrors for exceptions, and then passes its arguments to an appropriate method on that object.
.PP
You may import any of these functions by including their names in your 
\&\f(CW\*(C`use Text::MicroMason\*(C'\fR statement.
.Sh "Basic Invocation"
.IX Subsection "Basic Invocation"
To evaluate a Mason-like template, pass it to \fIexecute()\fR:
.PP
.Vb 1
\&  $result = execute( $mason_text );
.Ve
.PP
Alternately, you can call \fIcompile()\fR to generate a subroutine for your template, and then run the subroutine:
.PP
.Vb 1
\&  $result = compile( $mason_text )\->();
.Ve
.PP
If you will be interpreting the same template repeatedly, you can save the compiled version for faster execution:
.PP
.Vb 2
\&  $sub_ref = compile( $mason_text );
\&  $result = $sub_ref\->();
.Ve
.PP
(Note that the \f(CW$sub_ref\fR\->() syntax is unavailable in older versions of Perl; use the equivalent &$\fIsub_ref()\fR syntax instead.)
.Sh "Argument Passing"
.IX Subsection "Argument Passing"
You can also pass a list of key-value pairs as arguments to execute, or to the compiled subroutine:
.PP
.Vb 1
\&  $result = execute( $mason_text, %args );
.Ve
.PP
.Vb 1
\&  $result = $sub_ref\->( %args );
.Ve
.PP
Within the scope of your template, any arguments that were provided will be accessible in the global \f(CW@_\fR, the \f(CW%ARGS\fR hash, and any variables named in an \f(CW%args\fR block.
.PP
For example, the below calls will all return '<b>Foo</b>':
.PP
.Vb 3
\&  execute(\(aq<b><% shift(@_) %></b>\(aq, \(aqFoo\(aq);
\&  execute(\(aq<b><% $ARGS{label} %></b>\(aq, label=>\(aqFoo\(aq);
\&  execute(\(aq<%args>$label</%args><b><% $label %></b>\(aq, label=>\(aqFoo\(aq);
.Ve
.Sh "Template Files"
.IX Subsection "Template Files"
A parallel set of functions exist to handle templates which are stored in a file:
.PP
.Vb 2
\&  $template = compile_file( \(aq./report_tmpl.msn\(aq );
\&  $result = $template\->( %args );
.Ve
.PP
.Vb 1
\&  $result = execute_file( \(aq./report_tmpl.msn\(aq, %args );
.Ve
.PP
Template documents are just plain text files that contains the string to be parsed. The files may have any name you wish, and the .msn extension shown above is not required.
.Sh "Error Checking"
.IX Subsection "Error Checking"
Both compilation and run-time errors in your template are handled as fatal
exceptions. The provided \fItry_execute()\fR and \fItry_compile()\fR functions use a mixin class which wraps an eval { } block around the basic \fIexecute()\fR or \fIcompile()\fR
methods. In a scalar context they return the result of the call, or
undef if it failed; in a list context they return the results of the call
(undef if it failed) followed by the error message (undef if it succeeded).
For example:
.PP
.Vb 6
\&  ($result, $error) = try_execute( $mason_text );
\&  if ( ! $error ) {
\&    print $result;
\&  } else {
\&    print "Unable to execute template: $error";
\&  }
.Ve
.PP
A matching pair of try_*\fI_file()\fR wrappers are available to catch run-time errors in reading a file or parsing its contents:
.PP
.Vb 1
\&  ($template, $error) = try_compile_file( \(aq./report_tmpl.msn\(aq );
.Ve
.PP
.Vb 1
\&  ($result, $error) = try_execute_file( \(aq./report_tmpl.msn\(aq, %args );
.Ve
.PP
For more information, see Text::MicroMason::CatchErrors.
.Sh "Safe Compartments"
.IX Subsection "Safe Compartments"
If you wish to restrict the operations that a template can perform,
use the \fIsafe_compile()\fR and \fIsafe_execute()\fR functions, or their
try_*() wrappers.
.PP
For more information, see Text::MicroMason::Safe.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
For an overview of this templating framework, see Text::MicroMason.
.PP
For distribution, installation, support, copyright and license 
information, see Text::MicroMason::Docs::ReadMe.
