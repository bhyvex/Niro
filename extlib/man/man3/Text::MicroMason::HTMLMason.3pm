.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "MicroMason::HTMLMason 3"
.TH MicroMason::HTMLMason 3 "2007-01-30" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Text::MicroMason::HTMLMason \- Simple Compiler for Mason\-style Templating 
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Create a MicroMason object to interpret the templates:
.PP
.Vb 2
\&  use Text::MicroMason;
\&  my $mason = Text::MicroMason\->new();
.Ve
.PP
Use the standard compile and execute methods to parse and evalute templates:
.PP
.Vb 2
\&  print $mason\->compile( text=>$template )\->( @%args );
\&  print $mason\->execute( text=>$template, @args );
.Ve
.PP
Mason syntax provides several ways to mix Perl into a text template:
.PP
.Vb 3
\&  <%args>
\&    $name
\&  </%args>
.Ve
.PP
.Vb 9
\&  % if ( $name eq \(aqDave\(aq ) {
\&    I\(aqm sorry <% $name %>, I\(aqm afraid I can\(aqt do that right now.
\&  % } else {
\&    <%perl>
\&      my $hour = (localtime)[2];
\&      my $daypart = ( $hour > 11 ) ? \(aqafternoon\(aq : \(aqmorning\(aq; 
\&    </%perl>
\&    Good <% $daypart %>, <% $name %>!
\&  % }
.Ve
.PP
.Vb 1
\&  <& "includes/standard_footer.msn" &>
.Ve
.PP
.Vb 3
\&  <%doc>
\&    Here\(aqs a private developr comment describing this template. 
\&  </%doc>
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Text::MicroMason::HTMLMason class provides lexer and assembler methods that allow Text::MicroMason to handle most elements of HTML::Mason's template syntax.
.Sh "Compatibility with HTML::Mason"
.IX Subsection "Compatibility with HTML::Mason"
HTML::Mason is a full-featured application server toolkit with many fatures, of which only the templating functionality is emulated.
.PP
The following sets of HTML::Mason features \fBare\fR supported by Text::MicroMason:
.IP "\(bu" 4
Template interpolation with <% expr %> 
.IP "\(bu" 4
Literal Perl lines with leading % 
.IP "\(bu" 4
Named \f(CW%args\fR, \f(CW%perl\fR, \f(CW%once\fR, \f(CW%init\fR, \f(CW%cleanup\fR, and \f(CW%doc\fR blocks
.IP "\(bu" 4
The \f(CW$m\fR mason object, although with many fewer methods
.IP "\(bu" 4
Expression filtering with |h and |u (via \-Filter mixin)
.PP
The following sets of HTML::Mason features are \fBnot\fR supported by Text::MicroMason:
.IP "\(bu" 4
No \f(CW%attr\fR, \f(CW%flag\fR, \f(CW%shared\fR, \f(CW%method\fR, or \f(CW%def\fR blocks.
.IP "\(bu" 4
No shared files like autohandler and dhandler.
.IP "\(bu" 4
No \f(CW$r\fR request object. No mod_perl integration or configuration capability.
.PP
Contributed patches to add these features of HTML::Mason would be
welcomed by the author. Possible implemenations are described in
Text::MicroMason::ToDo.
.Sh "Private Methods"
.IX Subsection "Private Methods"
The following internal methods are used to implement the syntax described below.
.IP "lex_token" 4
.IX Item "lex_token"
.Vb 1
\&  ( $type, $value ) = $mason\->lex_token();
.Ve
.Sp
Supports HTML::Mason's markup syntax.
.Sp
Attempts to parse a token from the template text stored in the global \f(CW$_\fR and returns a token type and value. Returns an empty list if unable to parse further due to an error.
.IP "\fIassembler_rules()\fR" 4
.IX Item "assembler_rules()"
Returns a hash of text elements used for Perl subroutine assembly. Used by \fIassemble()\fR. 
.Sp
Supports HTML::Mason's named blocks of Perl code and documentation: \f(CW%once\fR, \f(CW%init\fR, \f(CW%cleanup\fR, and \f(CW%doc\fR.
.IP "assemble_args" 4
.IX Item "assemble_args"
Called by \fIassemble()\fR, this method provides support for Mason's <%args> blocks.
.SH "TEMPLATE SYNTAX"
.IX Header "TEMPLATE SYNTAX"
Here's an example of Mason-style templating, taken from HTML::Mason:
.PP
.Vb 3
\&    % my $noun = \(aqWorld\(aq;
\&    Hello <% $noun %>!
\&    How are ya?
.Ve
.PP
Interpreting this template with Text::MicroMason produces the same output as it would in HTML::Mason:
.PP
.Vb 2
\&    Hello World!
\&    How are ya?
.Ve
.PP
Text::MicroMason::HTMLMason supports a syntax that is mostly a subset of that used by HTML::Mason.
.Sh "Template Markup"
.IX Subsection "Template Markup"
The following types of markup are recognized in template pages:
.IP "\(bu" 4
\&\fIliteral_text\fR
.Sp
Anything not specifically parsed by one of the below rules is interpreted as literal text.
.IP "\(bu" 4
<% \fIperl_expr\fR %>
.Sp
A Perl expression to be interpolated into the result.
.Sp
For example, the following template text will return a scheduled
greeting:
.Sp
.Vb 1
\&    Good <% (localtime)[2]>11 ? \(aqafternoon\(aq : \(aqmorning\(aq %>.
.Ve
.Sp
The block may span multiple lines and is scoped inside a \*(L"do\*(R" block,
so it may contain multiple Perl statements and it need not end with
a semicolon.
.Sp
.Vb 2
\&    Good <% my $h = (localtime)[2]; $h > 11 ? \(aqafternoon\(aq 
\&                                            : \(aqmorning\(aq  %>.
.Ve
.IP "\(bu" 4
% \fIperl_code\fR
.Sp
Lines which begin with the % character, without any leading
whitespace, may contain arbitrary Perl code to be executed when
encountering this portion of the template.  Their result is not
interpolated into the result.
.Sp
For example, the following template text will return a scheduled
greeting:
.Sp
.Vb 2
\&    % my $daypart = (localtime)[2]>11 ? \(aqafternoon\(aq : \(aqmorning\(aq;
\&    Good <% $daypart %>.
.Ve
.Sp
The line may contain one or more statements.  This code is is not
placed in its own block scope, so it should typically end with a
semicolon; it can still open a spanning block scope closed by a later
perl block.
.Sp
For example, the following template text will return one of two different messages each time it's interpreted:
.Sp
.Vb 5
\&    % if ( int rand 2 ) {
\&      Hello World!
\&    % } else {
\&      Goodbye Cruel World!
\&    % }
.Ve
.Sp
This also allows you to quickly comment out sections of a template by prefacing each line with \f(CW\*(C`% #\*(C'\fR.
.Sp
This is equivalent to a <%perl>...</%perl> block.
.IP "\(bu" 4
<& \fItemplate_filename\fR, \fIarguments\fR &>
.Sp
Includes the results of a separate file containing MicroMason code, compiling it and executing it with any arguments passed after the filename.
.Sp
For example, we could place the following template text into an separate 
file:
.Sp
.Vb 1
\&    Good <% $ARGS{hour} >11 ? \(aqafternoon\(aq : \(aqmorning\(aq %>.
.Ve
.Sp
Assuming this file was named \*(L"greeting.msn\*(R", its results could be embedded within the output of another script as follows:
.Sp
.Vb 1
\&  <& "greeting.msn", hour => (localtime)[2] &>
.Ve
.IP "\(bu" 4
<%\fIname\fR> ... </%\fIname\fR>
.Sp
A named block contains a span of text. The name at the start and end must match, and must be one of the supported block names. 
.Sp
Depending on the name, performs one of the behaviors described in \*(L"Named Blocks\*(R".
.Sh "Named Blocks"
.IX Subsection "Named Blocks"
The following types of named blocks are supported:
.IP "\(bu" 4
<%perl> \fIperl_code\fR </%perl>
.Sp
Blocks surrounded by \f(CW%perl\fR tags may contain arbitrary Perl code.
Their result is not interpolated into the result.
.Sp
These blocks may span multiple lines in your template file. For
example, the below template initializes a Perl variable inside a
\&\f(CW%perl\fR block, and then interpolates the result into a message.
.Sp
.Vb 4
\&    <%perl> 
\&      my $count = join \(aq\(aq, map "$_... ", ( 1 .. 9 ); 
\&    </%perl>
\&    Here are some numbers: <% $count %>
.Ve
.Sp
The code may contain one or more statements.  This code is is not
placed in its own block scope, so it should typically end with a
semicolon; it can still open a spanning block scope closed by a later
perl block.
.Sp
For example, when the below template text is evaluated it will
return a sequence of digits:
.Sp
.Vb 8
\&    Here are some numbers: 
\&    <%perl> 
\&      foreach my $digit ( 1 .. 9 ) { 
\&    </%perl>
\&        <% $digit %>... 
\&    <%perl> 
\&      } 
\&    </%perl>
.Ve
.Sp
If the block is immediately followed by a line break, that break is
discarded.  These blocks are not whitespace sensitive, so the template
could be combined into a single line if desired.
.IP "\(bu" 4
<%args> \fIvariable\fR => \fIdefault\fR </%args>
.Sp
Defines a collection of variables to be initialized from named arguments passed to the subroutine. Arguments are separated by one or more newlines, and may optionally be followed by a default value. If no default value is provided, the argument is required and the subroutine will croak if it is not provided. 
.Sp
For example, adding the following block to a template will initialize the three named variables, and will fail if no \f(CW\*(C`a => '...'\*(C'\fR argument pair is passed:
.Sp
.Vb 5
\&  <%args>
\&    $a
\&    @b => qw( foo bar baz )
\&    %c => ()
\&  </%args>
.Ve
.Sp
All the arguments are available as lexically scoped (\*(L"my\*(R") variables in the rest of the component. Default expressions are evaluated in top-to-bottom order, and one expression may reference an earlier one.
.Sp
Only valid Perl variable names may be used in <%args> sections. Parameters with non-valid variable names cannot be pre-declared and must be fetched manually out of the \f(CW%ARGS\fR hash. 
.IP "\(bu" 4
<%init> \fIperl_code\fR </%init>
.Sp
Similar to a \f(CW%perl\fR block, except that the code is moved up to the start of
the subroutine. This allows a template's initialization code to be moved to
the end of the file rather than requiring it to be at the top.
.Sp
For example, the following template text will return a scheduled
greeting:
.Sp
.Vb 4
\&    Good <% $daypart %>.
\&    <%init> 
\&      my $daypart = (localtime)[2]>11 ? \(aqafternoon\(aq : \(aqmorning\(aq;
\&    </%init>
.Ve
.IP "\(bu" 4
<%cleanup> \fIperl_code\fR </%cleanup>
.Sp
Similar to a \f(CW%perl\fR block, except that the code is moved down to the end of the subroutine. 
.IP "\(bu" 4
<%once> \fIperl_code\fR </%once>
.Sp
Similar to a \f(CW%perl\fR block, except that the code is executed once,
when the template is first compiled. (If a caller is using execute,
this code will be run repeatedly, but if they call compile and then
invoke the resulting subroutine multiple times, the \f(CW%once\fR code will
only execute during the compilation step.)
.Sp
This code does not have access to \f(CW%ARGS\fR and can not generate output.
It can be used to define constants, create persistent variables,
or otherwise prepare the environment.
.Sp
For example, the following template text will return a increasing
number each time it is called:
.Sp
.Vb 4
\&    <%once> 
\&      my $counter = 1000;
\&    </%once>
\&    The count is <% ++ $counter %>.
.Ve
.IP "\(bu" 4
<%doc> ... </%doc>
.Sp
Provides space for template developer documentation or comments which are not included in the output.
.IP "\(bu" 4
<%text> ... </%text>
.Sp
Produces literal text in the template output. Can be used to surround text
that contains other markup tags that should not be interpreted.
.Sp
Equivalent to un-marked-up text.
.PP
The following types of named blocks are not supported by HTML::Mason, but are supported here as a side-effect of the way the lexer and assembler are implemented.
.IP "\(bu" 4
<%expr> ... </%expr>
.Sp
A Perl expression to be interpolated into the result.
The block may span multiple lines and is scoped inside a \*(L"do\*(R" block,
so it may contain multiple Perl statements and it need not end with
a semicolon. 
.Sp
Equivalent to the \f(CW\*(C`<% ... %>\*(C'\fR markup syntax.
.IP "\(bu" 4
<%file> \fItemplate_filename\fR, \fIarguments\fR </%file>
.Sp
Includes the results of a separate file containing MicroMason code, compiling it and executing it with any arguments passed after the filename.
.Sp
.Vb 1
\&  <%file> "greeting.msn", hour => (localtime)[2] </%file>
.Ve
.Sp
Equivalent to the \f(CW\*(C`<& ... &>\*(C'\fR markup syntax.
.SH "TEMPLATE CODING TECHNIQUES"
.IX Header "TEMPLATE CODING TECHNIQUES"
.Sh "Assembling Perl Source Code"
.IX Subsection "Assembling Perl Source Code"
When Text::MicroMason::Base assembles your lexed template into the
equivalent Perl subroutine, all of the literal (non\-Perl) pieces are
converted to \f(CW\*(C`$_out\->('text');\*(C'\fR statements, and the interpolated
expressions are converted to \f(CW\*(C`$_out\->( do { expr } );\*(C'\fR statements.
Code from \f(CW%perl\fR blocks and % lines are included exactly as\-is.
.PP
Your code is eval'd in the \f(CW\*(C`Text::MicroMason::Commands\*(C'\fR package. 
The \f(CW\*(C`use strict;\*(C'\fR pragma is enabled by default to simplify debugging.
.Sh "Internal Sub-templates"
.IX Subsection "Internal Sub-templates"
You can create sub-templates within your template text by defining
them as anonymous subroutines and then calling them repeatedly.
For example, the following template will concatenate the results of 
the draw_item sub-template for each of three items:
.PP
.Vb 1
\&    <h1>We\(aqve Got Items!</h1>
.Ve
.PP
.Vb 4
\&    % my $draw_item = sub {
\&      <p><b><% $_[0] %></b>:<br>
\&        <a href="/more?item=<% $_[0] %>">See more about <% $_[0] %>.</p>
\&    % };
.Ve
.PP
.Vb 5
\&    <%perl>
\&      foreach my $item ( qw( Foo Bar Baz ) ) {
\&        $draw_item\->( $item );
\&      }
\&    </%perl>
.Ve
.Sh "Returning Text from Perl Blocks"
.IX Subsection "Returning Text from Perl Blocks"
To append to the result from within Perl code, call \f(CW$_out\fR\->(\fItext\fR). 
(The \f(CW$_out\fR\->() syntax is unavailable in older versions of Perl; use the
equivalent &$\fI_out()\fR syntax instead.)
.PP
For example, the below template text will return '123456789' when it is
evaluated:
.PP
.Vb 5
\&    <%perl>
\&      foreach my $digit ( 1 .. 9 ) {
\&        $_out\->( $digit )
\&      }
\&    </%perl>
.Ve
.PP
You can also directly manipulate the value \f(CW@OUT\fR, which contains the
accumulating result. 
.PP
For example, the below template text will return an altered version of its
message if a true value for 'minor' is passed as an argument when the
template is executed:
.PP
.Vb 2
\&    This is a funny joke.
\&    % if ( $ARGS{minor} ) { foreach ( @OUT ) { tr[a\-z][n\-za\-m] } }
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
For a full-featured web application system using this template syntax, see HTML::Mason.
.PP
For an overview of this distribution, see Text::MicroMason.
.PP
This is a subclass intended for use with Text::MicroMason::Base.
.PP
For distribution, installation, support, copyright and license 
information, see Text::MicroMason::Docs::ReadMe.
